<!DOCTYPE html>

<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link rel="stylesheet" href="/static/base.css">
<title>NEURAL DX v6.0</title>
<link href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" rel="stylesheet"/>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&amp;family=Share+Tech+Mono&amp;display=swap" rel="stylesheet"/>
<style>
        /* Variables de Th√®me par D√©faut (SoftTech V4.1 Original) */
        :root {
            --bg-color: #050505;
            --panel-bg: #0e0e0e;
            --text-main: #a0a0a0;
            --accent: #00f3ff;
            --alert: #ff003c; /* Rouge vif pour Surge */
            --border: 1px solid #333;
            --wl-bg: #ffeb3b;
            --wl-text: #000000;
            --open-color: #d35400;
        }
        /* Th√®me Nuit (DarkMode V4.1 Original) */
        body[data-theme='dark'] {
            --bg-color: #1a1a1a;
            --panel-bg: #2a2a2a;
            --text-main: #f0f0f0;
            --accent: #00ff80;
            --alert: #ff6347;
            --border: 1px solid #555;
            --wl-bg: #ffff00;
            --wl-text: #000000;
            --open-color: #ffd700;
        }
        /* NOUVEAU: Th√®me Matrix (Hackergreen V4.2) */
        body[data-theme='matrix'] {
            --bg-color: #000000;
            --panel-bg: #031503;
            --text-main: #00ff41; /* Vert Matrix */
            --accent: #00ff41;
            --alert: #ff004c;
            --border: 1px solid #005500;
            --wl-bg: #4cff7e;
            --wl-text: #000000;
            --open-color: #00aa00;
        }
        /* NOUVEAU: Th√®me Sunset (Orange/Violet V4.2) */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Share Tech Mono', monospace;
        }
        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
        }
        #header {
            background-color: var(--panel-bg);
            padding: 10px 20px;
            border-bottom: var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5em;
            color: var(--accent);
            text-shadow: 0 0 5px var(--accent);
        }
        /* Ticker */
        #ticker-container {
            background-color: #0d0d0d;
            color: var(--text-main);
            padding: 5px 0;
            overflow: hidden;
            white-space: nowrap;
            border-bottom: var(--border);
            width: 100%;
        }
        #ticker-content {
            display: inline-block;
            padding-left: 100%;
            animation: ticker-roll 60s linear infinite;
        }

        @keyframes ticker-roll {
            0% { transform: translate(0, 0); }
            100% { transform: translate(-100%, 0); }
        }
        #main-container {
            display: grid;
            grid-template-columns: repeat(3, minmax(320px, 1fr));
            gap: 10px;
            padding: 10px;
            align-items: start;
        }
        @media (max-width: 1100px){
            #main-container{ grid-template-columns: repeat(2, minmax(280px, 1fr)); }
        }
        @media (max-width: 760px){
            #main-container{ grid-template-columns: 1fr; }
        }
        .column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .panel {
            background-color: var(--panel-bg);
            border: var(--border);
            border-radius: 5px;
            padding: 10px;
            min-height: 150px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .panel-header {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1em;
            color: var(--accent);
            margin-bottom: 8px;
            border-bottom: 1px dotted #333;
            padding-bottom: 5px;
            display: flex;
            align-items: center;
            cursor: grab;
        }

        /* Handle de Drag & Drop (le "crochet") */
        .dd-handle {
            font-size: 1.5em;
            cursor: grab;
            margin-right: 5px;
            color: var(--text-main);
            opacity: 0.5;
        }
        .dd-handle:hover {
            opacity: 1;
            color: var(--accent);
        }

        /* ALERTE SURGE (clignotant ROUGE) */
        #surge-panel.active-surge {
            border: 3px solid var(--alert);
            box-shadow: 0 0 15px var(--alert);
            animation: pulse-red 1s infinite alternate;
        }
        @keyframes pulse-red {
            from { box-shadow: 0 0 10px var(--alert); }
            to { box-shadow: 0 0 20px var(--alert), 0 0 5px var(--alert); }
        }
        /* Tableaux */
        .spot-table, .wl-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        /* Callsign en gras blanc (sauf Watchlist) */
        .spot-call-white-bold {
            color: #ffffff;
            font-weight: bold;
        }

        /* Assurer que le lien QRZ √† l'int√©rieur est √©galement en blanc */
        .spot-call-white-bold a {
            color: inherit !important;
        }


        /* Callsign Watchlist dans tableaux spots (fond jaune, lisible, sans "surbrillance") */
        .spot-call-watchlist {
            background-color: var(--wl-bg);
            color: var(--wl-text) !important;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
        }
        .spot-call-watchlist a {
            color: var(--wl-text) !important;
        }

        /* Watchlist dans tableaux spots (ligne compl√®te en fond jaune) */
        tr.spot-row-watchlist > td {
            background-color: #ffd54a !important;
            color: #000000 !important;
        }
        tr.spot-row-watchlist a {
            color: #000000 !important;
        }
        tr.spot-row-watchlist td {
            border-bottom-color: rgba(0,0,0,0.12) !important;
        }


        /* √âtiquettes de bande dans le tableau */
        .band-tag {
            display: inline-block;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
            color: #000;
            text-shadow: none;
        }

        /* Liens QRZ */
        .spot-table a {
            color: inherit;
            text-decoration: none;
        }
        .spot-table th, .spot-table td, .wl-table th, .wl-table td {
            padding: 4px;
            text-align: left;
            border-bottom: 1px dotted #1a1a1a;
        }
        .spot-table th {
            color: var(--text-main);
            background-color: #1a1a1a;
            position: sticky;
            top: 0;
        }

        .high-spd {
            color: var(--alert);
            font-weight: bold;
        }

        .wl-table td.call {
            color: var(--wl-text);
            background-color: var(--wl-bg);
            font-weight: bold;
            text-align: center;
        }
        #spots-container-hf, #spots-container-vhf, #watchlist-container {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 5px;
        }

        /* Maps */
        .map-panel {
            min-height: 250px;
        }
        .map-area {
            height: 220px;
            border: 1px solid #555;
            border-radius: 3px;
        }

        /* Formulaire QRA */
        #qra-form {
            display: flex;
            gap: 10px;
            margin-top: 5px;
            align-items: center;
        }
        #qra-form input[type="text"] {
            padding: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: var(--text-main);
            width: 80px;
            text-transform: uppercase;
        }
        #qra-form button {
            padding: 5px 10px;
            background-color: var(--accent);
            color: var(--panel-bg);
            border: none;
            cursor: pointer;
        }

        /* Contr√¥les Header */
        #controls {
            display: flex;
            align-items: center;
            gap: 10px; /* Espace entre les √©l√©ments de contr√¥le */
        }

        .icon-button {
            background: none;
            border: none;
            color: var(--accent);
            font-size: 1.2em;
            cursor: pointer;
            margin-left: 10px;
            text-decoration: none; /* Ajout pour la balise <a> */
            display: inline-block; /* Ajout pour la balise <a> */
            font-family: 'Orbitron', sans-serif;
            padding: 5px 10px;
        }
        .icon-button:hover {
             background-color: rgba(0, 243, 255, 0.1);
             border-radius: 3px;
        }
        /* Style sp√©cifique pour le bouton Synth√®se Vocale et Filtres */
        #synth-toggle-button, #voice-distance-filter, #voice-language-filter {
            background-color: #333;
            padding: 5px 10px;
            border-radius: 3px;
            color: var(--accent);
            font-size: 0.9em;
            cursor: pointer;
            border: 1px solid #555;
            font-family: 'Share Tech Mono', monospace;
        }

        #indicators {
            display: flex;
            gap: 15px;
            font-size: 0.9em;
        }
        .indicator-item {
            color: var(--text-main);
        }
        .indicator-item span {
            color: var(--accent);
            font-weight: bold;
        }
        .ranking-list {
            list-style: none;
            padding: 0;
        }
        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px dotted #222;
        }
        .ranking-call {
            color: var(--accent);
            font-weight: bold;
        }
        .ranking-score {
            color: var(--alert);
        }

        #surge-container {
            font-size: 1em;
            padding: 5px;
        }
        .surge-band {
            display: inline-block;
            background-color: var(--alert);
            color: #ffffff;
            padding: 2px 6px;
            margin: 3px;
            border-radius: 3px;
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
        }

        .filter-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
        }
        .filter-controls select {
            padding: 5px;
            background-color: #333;
            color: var(--text-main);
            border: 1px solid #555;
        }

        /* Style pour le panel du graphique d'historique */
        #chart-history-panel {
            min-height: 300px;
        }
        .chart-container {
            position: relative;
            height: 250px;
            width: 100%;
        }

        /* =========================
           SOLAR panel : couleurs + micro animation + explications
           ========================= */
        .solar-chip{
            display:inline-flex;
            align-items:center;
            gap:6px;
            padding:2px 10px;
            border-radius:999px;
            font-size:12px;
            border:1px solid rgba(0,243,255,.25);
            background:rgba(0,243,255,.06);
            margin-top:8px;
            width: fit-content;
        }
        .solar-chip::before{
            content:"";
            width:8px;
            height:8px;
            border-radius:50%;
            background: var(--accent);
            box-shadow: 0 0 10px rgba(0,243,255,.35);
            animation: solarPulse 1.6s ease-in-out infinite;
        }
        @keyframes solarPulse{
            0%,100%{ transform: scale(1); opacity:.65; }
            50%{ transform: scale(1.35); opacity:1; }
        }

        .chip-poor{ color:#ff4d4d; border-color:rgba(255,77,77,.35); background:rgba(255,77,77,.08); }
        .chip-fair{ color:#ffd24d; border-color:rgba(255,210,77,.35); background:rgba(255,210,77,.08); }
        .chip-good{ color:#4dff88; border-color:rgba(77,255,136,.35); background:rgba(77,255,136,.08); }
        .chip-exc{  color:#00eaff; border-color:rgba(0,234,255,.35); background:rgba(0,234,255,.08); }

        .solar-value-color-poor{ color:#ff4d4d !important; }
        .solar-value-color-fair{ color:#ffd24d !important; }
        .solar-value-color-good{ color:#4dff88 !important; }
        .solar-value-color-exc{  color:#00eaff !important; }

        .solar-updated{
            margin-top:6px;
            font-size:0.85em;
            opacity:0.9;
            color: var(--accent);
        }
        .solar-explain{
            margin-top:8px;
            font-size:0.82em;
            opacity:0.85;
            line-height:1.35;
        }
        .solar-explain b{ color: #ddd; }

        .hf-pred{
            margin-top:6px;
            font-size:0.85em;
            opacity:0.9;
        }
        .hf-pred span{
            color: var(--accent);
            font-weight:bold;
        }
    
        /* === V4 LOOK (pav√©s plus lisibles) === */
        .panel{
            border-radius: 14px !important;
            border: 1px solid rgba(255,255,255,0.18) !important;
            box-shadow: 0 10px 28px rgba(0,0,0,0.55), 0 0 0 1px rgba(255,255,255,0.06) inset !important;
            overflow: hidden;
        }
        body[data-theme='light'] .panel{
            border: 1px solid rgba(0,0,0,0.14) !important;
            box-shadow: 0 12px 26px rgba(0,0,0,0.10), 0 0 0 1px rgba(255,255,255,0.70) inset !important;
        }
        body[data-theme='matrix'] .panel{
            border: 1px solid rgba(0,255,65,0.45) !important;
            box-shadow: 0 10px 28px rgba(0,0,0,0.65), 0 0 0 1px rgba(0,255,65,0.10) inset !important;
        }

        .panel-header{
            padding: 10px 14px !important;
            border-bottom: 1px solid rgba(255,255,255,0.12) !important;
            letter-spacing: .06em !important;
            text-transform: uppercase !important;
        }
        body[data-theme='light'] .panel-header{
            border-bottom: 1px solid rgba(0,0,0,0.10) !important;
        }

        /* s√©parateurs internes */
        .meta-row, .list-item, .spot-row, .row{
            border-bottom-color: rgba(255,255,255,0.12) !important;
        }
        body[data-theme='light'] .meta-row, 
        body[data-theme='light'] .list-item,
        body[data-theme='light'] .spot-row,
        body[data-theme='light'] .row{
            border-bottom-color: rgba(0,0,0,0.10) !important;
        }


        /* === V4.0 LOOK (FORC√â) : pav√©s tr√®s lisibles === */
        .panel{
            background: var(--panel-bg) !important;
            border: 1px solid rgba(255,255,255,0.22) !important;
            border-radius: 16px !important;
            box-shadow: 0 14px 34px rgba(0,0,0,0.55), 0 0 0 1px rgba(255,255,255,0.06) inset !important;
            overflow: hidden !important;
        }
        body[data-theme='light'] .panel{
            border: 1px solid rgba(0,0,0,0.16) !important;
            box-shadow: 0 14px 30px rgba(0,0,0,0.12), 0 0 0 1px rgba(255,255,255,0.80) inset !important;
        }
        body[data-theme='matrix'] .panel{
            border: 1px solid rgba(0,255,65,0.55) !important;
            box-shadow: 0 14px 36px rgba(0,0,0,0.70), 0 0 0 1px rgba(0,255,65,0.12) inset !important;
        }
        .panel-header{
            padding: 12px 16px !important;
            border-bottom: 1px solid rgba(255,255,255,0.14) !important;
            letter-spacing: .08em !important;
            text-transform: uppercase !important;
            font-weight: 900 !important;
        }
        body[data-theme='light'] .panel-header{
            border-bottom: 1px solid rgba(0,0,0,0.10) !important;
        }
        /* espace entre colonnes/pav√©s */
        .dashboard-grid, .grid, .container{
            gap: 14px !important;
        }

</style>
</head>
<body>
<div id="header">
<div id="title">NEURAL DX WATCHER V6.0</div>
<div id="controls">
<span id="indicators">
<div class="indicator-item">QRA: <span id="qra-display">{{ user_qra }}</span></div>
<div class="indicator-item">UTC: <span id="utc-time"></span></div>
<div class="indicator-item">LOC: <span id="local-time"></span></div>
<div class="indicator-item">MODE: <span id="display-mode">SoftTech</span></div>
<a class="icon-button" href="analysis.html" title="Visualiser les algorithmes d'analyse">üìä AI INSIGHT</a>
<a class="icon-button" href="/briefing" title="Briefing DX">üõ∞Ô∏è BRIEFING</a>
<a class="icon-button" href="/map" title="DX Activity Map"> üó∫ MAP</a>
<a class="icon-button" href="/world" title="World"> üó∫ World</a>
</span>
<select id="voice-distance-filter" title="Filtrer les annonces vocales par distance">
<option value="ALL">Voice Dist: ALL</option>
<option value="LOW">Voice Dist: &lt; 5000 km</option>
<option value="MID">Voice Dist: 5000 - 10000 km</option>
<option value="HIGH">Voice Dist: &gt; 10000 km</option>
</select>
<select id="voice-language-filter" title="S√©lectionner la langue de l'annonce vocale">
<option value="fr-FR">Voice Lang: FR</option>
<option value="en-US">Voice Lang: EN</option>
<option value="es-ES">Voice Lang: ES</option>
<option value="he-IL">Voice Lang: HE</option>
</select>
<button id="synth-toggle-button" onclick="toggleVoiceSynth()" title="Activer/D√©sactiver la synth√®se vocale">üîä VOICE ON</button>
<button class="icon-button" onclick="toggleTheme()" title="Changer de th√®me">üîÜ</button>
</div>
</div>
<div id="ticker-container">
<div id="ticker-content">SYSTEM INITIALIZATION...</div>
</div>
<div id="main-container">
<div class="column" id="col1">
<div class="panel" data-panel-id="watchlist" id="watchlist-panel">
<div class="panel" data-panel-id="wl-tracking" id="wl-tracking-panel">
  <div class="panel-header">
    <span class="dd-handle">‚ãÆ‚ãÆ</span>
    WATCHLIST ¬∑ TRACKING
  </div>

  <div style="display:flex; gap:8px; margin-bottom:8px;">
    <input id="wl-track-filter"
           placeholder="Filtre call (ex: JA, /P)"
           style="flex:1; padding:6px; background:#111; border:1px solid #333; color:var(--text-main);">
    <select id="wl-track-limit" style="background:#111; color:var(--text-main); border:1px solid #333;">
      <option value="5">5</option>
      <option value="10" selected>10</option>
    </select>
    <button id="wl-track-refresh"
            style="padding:6px 10px; background:var(--accent); color:var(--panel-bg); border:none;">
      ‚ü≥
    </button>
  </div>

  <div id="wl-track-status" style="font-size:0.8em; opacity:.8; margin-bottom:6px;">
    Initialisation‚Ä¶
  </div>

  <div id="wl-track-body" style="display:flex; flex-direction:column; gap:8px;">
  </div>
</div>

<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> WATCHLIST</div>
<form id="add-wl-form" style="display: flex; gap: 5px; margin-bottom: 10px;">
<input id="wl_callsign" placeholder="Callsign √† ajouter" required="" style="flex-grow: 1; padding: 5px; border: 1px solid #555; background-color: #333; color: var(--text-main); text-transform: uppercase;" type="text"/>
<button style="padding: 5px 10px; background-color: var(--accent); color: var(--panel-bg); border: none; cursor: pointer;" type="submit">Add</button>
</form>
<div id="watchlist-container">
<table class="wl-table">
<thead>
<tr>
<th>Call</th>
<th>Band</th>
<th>Mode</th>
<th>Action</th>
</tr>
</thead>
<tbody id="watchlist-body">
<tr><td colspan="4" style="text-align: center;">Loading Watchlist...</td></tr>
</tbody>
</table>
</div>
</div>
<div class="panel" data-panel-id="spotter" id="spotter-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> SPOT MANUEL</div>
<div class="panel-body">
<div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:end;">
<div>
<label style="display:block; font-size:.85em; opacity:.8; margin-bottom:4px;">Indicatif (CALL)</label>
<input id="spot-call" placeholder="ex: DU2W" style="width:100%; padding:8px; background:#111; border:1px solid #333; color:#eee; border-radius:6px; text-transform:uppercase;" type="text"/>
</div>
<div>
<label style="display:block; font-size:.85em; opacity:.8; margin-bottom:4px;">Fr√©quence (MHz ou kHz)</label>
<input id="spot-freq" placeholder="ex: 14.074 ou 14074.0" style="width:100%; padding:8px; background:#111; border:1px solid #333; color:#eee; border-radius:6px;" type="text"/>
</div>
<div style="grid-column:1 / -1;">
<label style="display:block; font-size:.85em; opacity:.8; margin-bottom:4px;">Commentaire (optionnel)</label>
<input id="spot-comment" placeholder="ex: FT4, loud, QO-100, etc." style="width:100%; padding:8px; background:#111; border:1px solid #333; color:#eee; border-radius:6px;" type="text"/>
</div>
<div style="grid-column:1 / -1; display:flex; gap:8px; align-items:center;">
<button id="spot-send" style="padding:10px 14px; border-radius:8px; border:1px solid #355; background:rgba(0,243,255,.12); color:#e8ffff; cursor:pointer;">
                                üì° SPOT
                            </button>
<span id="spot-status" style="font-size:.9em; opacity:.85;"></span>
</div>
</div>
<div style="margin-top:8px; font-size:.8em; opacity:.65;">
                        Astuce : si tu saisis <b>14.074</b> (MHz), √ßa sera envoy√© au cluster en <b>14074.0</b>. Si tu saisis d√©j√† <b>14074.0</b>, c‚Äôest envoy√© tel quel.
                    </div>
</div>
</div>
<div class="panel" data-panel-id="spots-hf" id="spots-hf-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> DX SPOTS HF</div>
<div class="filter-controls">
<select id="hf-band-filter">
<option value="All">All Bands</option>
                        {% for band in hf_bands %}
                            <option value="{{ band }}">{{ band }}</option>
                        {% endfor %}
                    </select>
<select id="hf-mode-filter">
<option value="All">All Modes</option>
<option value="FT8">FT8</option>
<option value="CW">CW</option>
<option value="SSB">SSB</option>
<option value="FT4">FT4</option>
<option value="RTTY">RTTY</option>
<option value="SSTV">SSTV</option>
<option value="DIGI">DIGI</option>
</select>
</div>
<div id="spots-container-hf">
<table class="spot-table">
<thead>
<tr>
<th>Time</th><th>Freq</th><th>Call</th><th>Band</th><th>Mode</th><th title="Score de Priorit√© DX">SPD</th><th>Dist (km)</th>
</tr>
</thead>
<tbody id="spots-body-hf">
<tr><td colspan="7" style="text-align: center;">Waiting for spots...</td></tr>
</tbody>
</table>
</div>
</div>
<div class="panel" data-panel-id="spots-vhf" id="spots-vhf-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> DX SPOTS VHF/UHF</div>
<div class="filter-controls">
<select id="vhf-band-filter">
<option value="All">All Bands</option>
                        {% for band in vhf_bands %}
                            <option value="{{ band }}">{{ band }}</option>
                        {% endfor %}
                    </select>
<select id="vhf-mode-filter">
<option value="All">All Modes</option>
<option value="FT8">FT8</option>
<option value="MSK144">MSK144</option>
<option value="CW">CW</option>
<option value="SSB">SSB</option>
<option value="FM">FM</option>
</select>
</div>
<div id="spots-container-vhf">
<table class="spot-table">
<thead>
<tr>
<th>Time</th><th>Freq</th><th>Call</th><th>Band</th><th>Mode</th><th title="Score de Priorit√© DX">SPD</th><th>Dist (km)</th>
</tr>
</thead>
<tbody id="spots-body-vhf">
<tr><td colspan="7" style="text-align: center;">Waiting for spots...</td></tr>
</tbody>
</table>
</div>
</div>
<div class="panel" data-panel-id="wanted" id="wanted-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> DX WANTED (TOP 10)</div>
<div style="display: flex; gap: 20px;">
<div style="flex: 1;">
<h4 style="color: var(--accent);">HF</h4>
<ul class="ranking-list" id="ranking-hf"><li>Loading...</li></ul>
</div>
<div style="flex: 1;">
<h4 style="color: var(--accent);">VHF/UHF</h4>
<ul class="ranking-list" id="ranking-vhf"><li>Loading...</li></ul>
</div>
</div>
</div>
</div>

<div class="column" id="col2">
<div class="panel map-panel" data-panel-id="map-hf" id="map-hf-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> DX MAP HF ({{ hf_bands|length }} Bands)</div>
<div class="map-area" id="map-hf"></div>
</div>
<div class="panel map-panel" data-panel-id="map-vhf" id="map-vhf-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> DX MAP VHF/UHF ({{ vhf_bands|length }} Bands)</div>
<div class="map-area" id="map-vhf"></div>
</div>
</div>

<div class="column" id="col3">
<div class="panel" data-panel-id="surge" id="surge-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> SURGE ALERTS ‚ö°</div>
<div id="surge-container">No active surges...</div>
</div>

<div class="panel" data-panel-id="solar" id="solar-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> SOLAR INDICES ‚òÄÔ∏è</div>
<div id="solar-content">
<div style="display:flex; gap:16px; flex-wrap:wrap; align-items:baseline;">
<div class="indicator-item">SFI: <span id="solar-sfi">--</span></div>
<div class="indicator-item">A: <span id="solar-a">--</span></div>
<div class="indicator-item">K: <span id="solar-k">--</span></div>
</div>

<div id="solar-chip" class="solar-chip">SFI Status: --</div>

<div id="hf-prediction" class="hf-pred">HF: <span>--</span></div>

<div class="solar-updated">
                        Updated (UTC): <span id="solar-updated">--</span>
</div>

<div class="solar-explain">
<b>FR</b> : <b>SFI</b> √©lev√© = plus de chances d‚Äôouverture HF (10‚Äì12‚Äì15m). <b>A</b> et <b>K</b> mesurent l‚Äôagitation g√©omagn√©tique : plus c‚Äôest haut, plus la propagation peut devenir instable.<br/>
<b>EN</b> : Higher <b>SFI</b> often helps HF openings (10‚Äì12‚Äì15m). <b>A</b> and <b>K</b> indicate geomagnetic disturbance: higher values can mean less stable propagation.
</div>

<div id="solar-error" style="margin-top:6px; font-size:0.85em; color: var(--alert); display:none;"></div>
</div>
</div>

<div class="panel" data-panel-id="qth" id="qth-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> QTH &amp; CONFIG</div>
<form id="qra-form">
<label for="qra_locator">Set QRA:</label>
<input id="qra_locator" name="qra_locator" placeholder="JN23" required="" type="text"/>
<button type="submit">Update</button>
</form>
<p style="margin-top: 10px; font-size: 0.8em; color: #888;">
                    My Call: {{ my_call }} | SPD Threshold: {{ spd_threshold }} | Version: {{ version }}
                </p>
</div>

<div class="panel" data-panel-id="chart-history" id="chart-history-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> HISTORIQUE 30MIN (12H)</div>
<div class="chart-container">
<canvas id="historyChart"></canvas>
</div>
</div>

<div class="panel" data-panel-id="chart-live-hf" id="chart-live-hf-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> LIVE BAND ACTIVITY (HF)</div>
<div style="height: 200px;"><canvas id="liveHFChart"></canvas></div>
</div>

<div class="panel" data-panel-id="chart-live-vhf" id="chart-live-vhf-panel">
<div class="panel-header"><span class="dd-handle" title="Drag &amp; Drop">‚ãÆ‚ãÆ</span> LIVE BAND ACTIVITY (VHF)</div>
<div style="height: 200px;"><canvas id="liveVHFChart"></canvas></div>
</div>
</div>
</div>

<script>
        // --- VARIABLES GLOBALES (DU BACKEND) ---
        const MY_CALL = '{{ my_call }}';
        const SPD_THRESHOLD = {{ spd_threshold }};
        const DEFAULT_QRA = '{{ user_qra }}';

        // --- √âTATS GLOBAUX (CLIENT) ---
        let userLatLng = [43.10, 5.88];
        let mapHF, mapVHF;
        let userMarkerHF, userMarkerVHF;
        let markersHF = new L.LayerGroup();
        let markersVHF = new L.LayerGroup();
        let watchlist = new Set();
        let historyChart, liveHFChart, liveVHFChart;
        let isVoiceEnabled = true;
        let voiceDistanceFilter = 'ALL';
        let voiceLanguageFilter = 'fr-FR'; 
        let announcedSpots = new Set(); 

        // --- UTILITAIRES ---
        function qraToLatLng(qra) {
            try {
                qra = qra.toUpperCase().trim();
                if (qra.length < 4) return [0, 0];

                let lon = -180 + (qra.charCodeAt(0) - 65) * 20 + (parseInt(qra[2]) * 2) + 1;
                let lat = -90 + (qra.charCodeAt(1) - 65) * 10 + (parseInt(qra[3]) * 1) + 0.5;

                if (qra.length >= 6) {
                    lon += (qra.charCodeAt(4) - 65) * (2/24) + (1/24);
                    lat += (qra.charCodeAt(5) - 65) * (1/24) + (1/48);
                }

                return [lat, lon];
            } catch (e) {
                console.error("Invalid QRA format:", qra, e);
                return [0, 0];
            }
        }

        function updateTimeDisplay() {
            const now = new Date();
            const utcTime = now.toUTCString().split(' ')[4];
            const localTime = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            document.getElementById('utc-time').textContent = utcTime;
            document.getElementById('local-time').textContent = localTime;
        }

        function getColorByScore(score) {
            if (score >= 90) return '#FF0000';
            if (score >= SPD_THRESHOLD) return '#FF8C00';
            if (score >= 50) return '#FFD700';
            return '#00BFFF';
        }

        function isWanted(call) {
            return watchlist.has(call.toUpperCase());
        }
        
        // UTILITY: R√©cup√®re la valeur d'une variable CSS
        function getCssVar(name) {
             return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || '#a0a0a0';
        }

        // --- Synth√®se vocale ---
        function toggleVoiceSynth() {
            isVoiceEnabled = !isVoiceEnabled;
            const button = document.getElementById('synth-toggle-button');
            if (isVoiceEnabled) {
                button.textContent = 'üîä VOICE ON';
                console.log('Synth√®se vocale activ√©e.');
            } else {
                button.textContent = 'üîá VOICE OFF';
                window.speechSynthesis.cancel(); 
                console.log('Synth√®se vocale d√©sactiv√©e.');
            }
            localStorage.setItem('voiceEnabled', isVoiceEnabled);
        }

        function isDistanceFiltered(distanceKm) {
            const filter = voiceDistanceFilter;
            if (filter === 'ALL') {
                return true;
            } else if (filter === 'LOW') { 
                return distanceKm < 5000;
            } else if (filter === 'MID') { 
                return distanceKm >= 5000 && distanceKm <= 10000;
            } else if (filter === 'HIGH') { 
                return distanceKm > 10000;
            }
            return true;
        }

        function announceSpot(spot) {
            if (!isVoiceEnabled || !('speechSynthesis' in window)) return;

            const spotKey = `${spot.dx_call}-${spot.freq}-${spot.time}`;
            if (announcedSpots.has(spotKey)) return;
            if (!isDistanceFiltered(spot.distance_km)) return;

            announcedSpots.add(spotKey);

            const message = new SpeechSynthesisUtterance();
            message.lang = voiceLanguageFilter;
            message.rate = 1.0;

            if (voiceLanguageFilter === 'fr-FR') {
                message.text =
                    `Spot d√©tect√© : ${spot.dx_call} sur ${spot.band}, ` +
                    `mode ${spot.mode}, fr√©quence ${spot.freq}. ` +
                    `Distance ${spot.distance_km.toFixed(0)} kilom√®tres.`;

            } else if (voiceLanguageFilter === 'es-ES') {
                message.text =
                    `Spot detectado: ${spot.dx_call} en la banda ${spot.band}, ` +
                    `modo ${spot.mode}, frecuencia ${spot.freq}. ` +
                    `Distancia ${spot.distance_km.toFixed(0)} kil√≥metros.`;

            } else if (voiceLanguageFilter === 'he-IL') {
                message.text =
                    `◊ñ◊ï◊î◊™◊î ◊™◊ó◊†◊î ${spot.dx_call} ` +
                    `◊ë◊™◊ó◊ï◊ù ${spot.band}, ◊û◊¶◊ë ${spot.mode}, ` +
                    `◊™◊ì◊® ${spot.freq}. ` +
                    `◊û◊®◊ó◊ß ${spot.distance_km.toFixed(0)} ◊ß◊ô◊ú◊ï◊û◊ò◊®◊ô◊ù.`;

            } else {
                message.text =
                    `DX spot: ${spot.dx_call} on ${spot.band} band, ` +
                    `mode ${spot.mode}, frequency ${spot.freq}. ` +
                    `Distance ${spot.distance_km.toFixed(0)} kilometers.`;
            }

            window.speechSynthesis.speak(message);
        }

        // --- WATCHLIST ---
        async function loadWatchlist() {
            try {
                const response = await fetch('/watchlist.json');
                const data = await response.json();
                watchlist = new Set(data);
                displayWatchlist();
            } catch(e) {
                console.error("Failed to load watchlist:", e);
                document.getElementById('watchlist-body').innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--alert);">Watchlist Load Error</td></tr>';
            }
        }

        function displayWatchlist() {
             const body = document.getElementById('watchlist-body');
             body.innerHTML = '';
             if (watchlist.size === 0) {
                 body.innerHTML = '<tr><td colspan="4" style="text-align: center;">Watchlist is empty.</td></tr>';
                 return;
             }

             watchlist.forEach(call => {
                 const row = body.insertRow();
                 row.innerHTML = `
                    <td class="call"><a href="https://qrz.com/db/${call}" target="_blank" style="color: inherit;">${call}</a></td>
                    <td>-</td>
                    <td>-</td>
                    <td><button onclick="removeFromWatchlist('${call}')" style="color: var(--alert); border: none; background: none; cursor: pointer;">[X]</button></td>
                 `;
             });
        }

        async function removeFromWatchlist(call) {
            try {
                const response = await fetch('/watchlist.json', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ call: call })
                });
                if (response.ok) {
                    watchlist.delete(call.toUpperCase());
                    displayWatchlist();
                }
            } catch (e) {
                console.error("Failed to remove from watchlist:", e);
            }
        }

        async function addToWatchlist(call) {
             try {
                const response = await fetch('/watchlist.json', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ call: call })
                });
                if (response.ok) {
                    watchlist.add(call.toUpperCase());
                    await updateData();
                }
            } catch (e) {
                console.error("Failed to add to watchlist:", e);
            }
        }

        // --- CARTOGRAPHIE (LEAFLET) ---
        function initMap(mapId) {
            const map = L.map(mapId, {
                worldCopyJump: true,
                center: userLatLng,
                zoom: 3,
                layers: [
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                        subdomains: 'abcd',
                        maxZoom: 19
                    })
                ]
            });
            map.attributionControl.setPrefix(false);
            return map;
        }

        function addUserMarker(map, lat, lon) {
            const marker = L.marker([lat, lon], {
                icon: L.divIcon({
                    className: 'user-marker',
                    html: `<div style="color:var(--accent); font-weight:bold; font-size:1.2em; text-shadow: 0 0 4px #000;">${MY_CALL}</div>`,
                    iconSize: [50, 20],
                    iconAnchor: [25, 10]
                })
            }).addTo(map);
            return marker;
        }

        function updateMaps(spots) {
            markersHF.clearLayers();
            markersVHF.clearLayers();
            spots.forEach(spot => {
                if (spot.lat && spot.lon && !isNaN(spot.lat) && !isNaN(spot.lon)) {
                    const markerIcon = L.divIcon({
                        className: 'dx-marker-point',
                        html: `<div style="width: 10px; height: 10px; background-color: ${spot.color}; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 0 5px ${spot.color};"></div>`,
                        iconSize: [14, 14],
                        iconAnchor: [7, 7]
                    });
                    const marker = L.marker([spot.lat, spot.lon], { icon: markerIcon });
                    marker.bindPopup(`
                        <b>${spot.dx_call}</b><br>
                        Freq: ${spot.freq} (${spot.band})<br>
                        Mode: ${spot.mode}<br>
                        SPD: ${spot.score} | Dist: ${spot.distance_km.toFixed(0)} km
                    `);
                    if (spot.type === 'HF') {
                        markersHF.addLayer(marker);
                    } else if (spot.type === 'VHF') {
                        markersVHF.addLayer(marker);
                    }
                } else {
                    console.warn(`Coordonn√©es invalides pour ${spot.dx_call}: Lat=${spot.lat}, Lon=${spot.lon}`);
                }
            });
            if (!markersHF.getLayers().length) { mapHF.setView(userLatLng, 3); }
            if (!markersVHF.getLayers().length) { mapVHF.setView(userLatLng, 3); }

            markersHF.addTo(mapHF);
            markersVHF.addTo(mapVHF);
        }

        // --- GRAPHIQUES (CHARTS.JS) ---
        function initCharts() {
            const mainColor = getCssVar('--text-main');
            const accentColor = getCssVar('--accent');

            Chart.defaults.color = mainColor;
            Chart.defaults.font.family = 'Share Tech Mono', 'monospace';

            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { color: mainColor }
                    },
                    title: {
                        display: true,
                        text: 'HISTORIQUE DES SPOTS (30MIN/12H)',
                        color: accentColor,
                        font: { size: 14, family: "'Orbitron', sans-serif" }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        titleColor: '#ffffff',
                        bodyColor: '#ffffff',
                        borderColor: accentColor,
                        borderWidth: 1
                    }
                },
                scales: {
                    x: {
                        ticks: { color: mainColor },
                        title: { display: true, text: 'Heure (UTC - 30min)', color: mainColor },
                        grid: { color: '#333' }
                    },
                    y: {
                        beginAtZero: true,
                        ticks: { color: mainColor },
                        title: { display: true, text: 'Nombre de spots', color: mainColor },
                        grid: { color: '#333' }
                    }
                }
            };

            const historyCtx = document.getElementById('historyChart').getContext('2d');
            historyChart = new Chart(historyCtx, { type: 'line', data: { labels: [], datasets: [] }, options: chartOptions });

            const liveHFCtx = document.getElementById('liveHFChart').getContext('2d');
            liveHFChart = new Chart(liveHFCtx, { type: 'bar', data: { labels: [], datasets: [] }, options: JSON.parse(JSON.stringify(chartOptions)) });

            const liveVHFCtx = document.getElementById('liveVHFChart').getContext('2d');
            liveVHFChart = new Chart(liveVHFCtx, { type: 'bar', data: { labels: [], datasets: [] }, options: JSON.parse(JSON.stringify(chartOptions)) });
        }

        function updateChartColors() {
             const mainColor = getCssVar('--text-main');
             const accentColor = getCssVar('--accent');
             Chart.defaults.color = mainColor;

             if (historyChart) {
                 historyChart.options.plugins.legend.labels.color = mainColor;
                 historyChart.options.plugins.title.color = accentColor;
                 historyChart.options.scales.x.ticks.color = mainColor;
                 historyChart.options.scales.x.title.color = mainColor;
                 historyChart.options.scales.y.ticks.color = mainColor;
                 historyChart.options.scales.y.title.color = mainColor;
                 historyChart.options.plugins.tooltip.borderColor = accentColor;
                 historyChart.update();
             }
             if (liveHFChart) { 
                liveHFChart.options.plugins.title.color = accentColor;
                liveHFChart.options.scales.x.ticks.color = mainColor;
                liveHFChart.options.scales.y.ticks.color = mainColor;
                liveHFChart.update(); 
             }
             if (liveVHFChart) { 
                liveVHFChart.options.plugins.title.color = accentColor;
                liveVHFChart.options.scales.x.ticks.color = mainColor;
                liveVHFChart.options.scales.y.ticks.color = mainColor;
                liveVHFChart.update(); 
             }
        }

        function updateHistoryChart(data) {
            const BAND_COLORS_JS = JSON.parse('{{ band_colors | tojson }}'); 

            const bands = Object.keys(data.data);
            const datasets = bands.map(band => ({
                label: band.toUpperCase(),
                data: data.data[band],
                borderColor: BAND_COLORS_JS[band] || '#ccc',
                backgroundColor: (BAND_COLORS_JS[band] || '#ccc') + '33',
                tension: 0.3,
                fill: true,
                pointRadius: 3,
                pointBackgroundColor: BAND_COLORS_JS[band] || '#ccc'
            }));

            historyChart.data.labels = data.labels;
            historyChart.data.datasets = datasets;
            historyChart.options.plugins.title.text = 'HISTORIQUE DES SPOTS (30MIN/12H)';
            historyChart.update();
        }

        function updateLiveBandsChart(chart, chartData) {
            chart.data.labels = chartData.labels;
            chart.data.datasets = [{
                label: 'Spots Actifs',
                data: chartData.data,
                backgroundColor: chartData.colors.map(c => c + 'AA'),
                borderColor: chartData.colors,
                borderWidth: 1
            }];
            chart.options.scales.x.title.text = 'Bande';
            chart.options.scales.y.title.text = 'Spots Actifs';
            chart.update();
        }

        function clearExpiredAnnouncedSpots(allActiveSpots) {
             const activeKeys = new Set(allActiveSpots.map(s => `${s.dx_call}-${s.freq}-${s.time}`));
             const newAnnouncedSpots = new Set();
             announcedSpots.forEach(key => { if (activeKeys.has(key)) newAnnouncedSpots.add(key); });
             announcedSpots = newAnnouncedSpots; 
        }

        // =========================
        // SOLAR: status + HF prediction + update time robust
        // =========================
        function pickSolarUpdated(d){
            return d.updated_utc || d.ts_utc || d.ts || d.timestamp || d.time || d.updated || d.last_update || null;
        }
        function sfiStatus(v){
            if (v < 90)  return ["POOR", "chip-poor", "solar-value-color-poor"];
            if (v < 120) return ["FAIR", "chip-fair", "solar-value-color-fair"];
            if (v < 160) return ["GOOD", "chip-good", "solar-value-color-good"];
            return ["EXCELLENT", "chip-exc", "solar-value-color-exc"];
        }
        function geomagStatusAK(a, k){
            // simple & lisible: on prend le "pire" des deux
            // Quiet: A<=10 & K<=2 / Unsettled: A<=20 & K<=4 / Storm: sinon
            const aNum = Number(a);
            const kNum = Number(k);
            if (!Number.isNaN(aNum) && !Number.isNaN(kNum)) {
                if (aNum <= 10 && kNum <= 2) return ["QUIET", "solar-value-color-good"];
                if (aNum <= 20 && kNum <= 4) return ["UNSETTLED", "solar-value-color-fair"];
                return ["STORM", "solar-value-color-poor"];
            }
            return ["--", ""];
        }
        function hfPrediction(sfi){
            if (sfi < 90)  return "10‚Äì12m: CLOSED ¬∑ 15‚Äì20m: FAIR ¬∑ 40‚Äì80m: GOOD (Night)";
            if (sfi < 120) return "10‚Äì12m: UNSTABLE ¬∑ 15‚Äì20m: GOOD ¬∑ 40‚Äì80m: NIGHT ONLY";
            if (sfi < 160) return "10‚Äì12m: OPEN ¬∑ 15‚Äì20m: VERY GOOD ¬∑ 40‚Äì80m: NIGHT";
            return "10‚Äì12m: WIDE OPEN ¬∑ 15‚Äì20m: EXCELLENT ¬∑ 40‚Äì80m: LIMITED";
        }

        // --- SOLAR INDICES ---
        async function fetchSolar() {
            try {
                const r = await fetch('/solar.json', { cache: 'no-store' });
                if (!r.ok) throw new Error(`HTTP ${r.status}`);
                const d = await r.json();

                const sfiRaw = (d.sfi === null || d.sfi === undefined) ? 'N/A' : d.sfi;
                const aRaw   = (d.a   === null || d.a   === undefined) ? 'N/A' : d.a;
                const kRaw   = (d.k   === null || d.k   === undefined) ? 'N/A' : d.k;

                // Heure: robuste (corrige ton bug "updated_utc uniquement")
                const updated = pickSolarUpdated(d) || 'N/A';

                const elSfi = document.getElementById('solar-sfi');
                const elA   = document.getElementById('solar-a');
                const elK   = document.getElementById('solar-k');

                elSfi.textContent = sfiRaw;
                elA.textContent   = aRaw;
                elK.textContent   = kRaw;
                document.getElementById('solar-updated').textContent = updated;

                // Reset classes
                elSfi.className = "";
                elA.className = "";
                elK.className = "";

                // SFI status
                const sfiNum = Number(sfiRaw);
                const chip = document.getElementById('solar-chip');
                const pred = document.getElementById('hf-prediction');

                if (!Number.isNaN(sfiNum)) {
                    const [label, chipCls, valueCls] = sfiStatus(sfiNum);
                    chip.textContent = `SFI Status: ${label}`;
                    chip.className = `solar-chip ${chipCls}`;
                    elSfi.classList.add(valueCls);
                    pred.innerHTML = `HF: <span>${hfPrediction(sfiNum)}</span>`;
                } else {
                    chip.textContent = `SFI Status: --`;
                    chip.className = "solar-chip";
                    pred.innerHTML = `HF: <span>--</span>`;
                }

                // A/K status tint (simple)
                const [akLabel, akCls] = geomagStatusAK(aRaw, kRaw);
                if (akCls) {
                    elA.classList.add(akCls);
                    elK.classList.add(akCls);
                }
                // (optionnel) tu pourrais afficher akLabel si tu veux, mais tu n‚Äôas pas demand√©.

                const err = document.getElementById('solar-error');
                err.style.display = 'none';
                err.textContent = '';
            } catch (e) {
                console.error('Solar fetch failed:', e);
                const err = document.getElementById('solar-error');
                if (err) {
                    err.textContent = 'Solar data unavailable';
                    err.style.display = 'block';
                }
            }
        }

        async function updateData() {
            console.log("Fetching new data...");
            await updateSpots('hf');
            await updateSpots('vhf');
            
            try {
                const allSpotsResponse = await fetch('/spots.json');
                const allSpots = await allSpotsResponse.json();
                updateMaps(allSpots);
                clearExpiredAnnouncedSpots(allSpots); 
            } catch(e) { console.error("Failed to fetch all spots for map/cleanup:", e); }

            try {
                const wantedResponse = await fetch('/wanted.json');
                const wantedData = await wantedResponse.json();
                displayRanking('ranking-hf', wantedData.hf);
                displayRanking('ranking-vhf', wantedData.vhf);
            } catch(e) { console.error("Failed to fetch ranking:", e); }

            try {
                const surgeResponse = await fetch('/surge.json');
                const surgeData = await surgeResponse.json();
                displaySurges(surgeData.surges);
            } catch(e) { console.error("Failed to fetch surges:", e); }

            try {
                const rssResponse = await fetch('/rss.json');
                const rssData = await rssResponse.json();
                document.getElementById('ticker-content').textContent = rssData.ticker;
            } catch(e) {
                console.error("Failed to fetch RSS/Ticker:", e);
                document.getElementById('ticker-content').textContent = "ERROR: Ticker data retrieval failed.";
            }

            try {
                const historyResponse = await fetch('/history.json');
                const historyData = await historyResponse.json();
                updateHistoryChart(historyData);
            } catch (e) { console.error("Failed to fetch history data:", e); }

            try {
                const liveBandsResponse = await fetch('/live_bands.json');
                const liveBandsData = await liveBandsResponse.json();
                updateLiveBandsChart(liveHFChart, liveBandsData.hf);
                updateLiveBandsChart(liveVHFChart, liveBandsData.vhf);
            } catch (e) { console.error("Failed to fetch live bands data:", e); }

            await loadWatchlist();
        }

        async function updateSpots(type) {
            const bodyId = `spots-body-${type}`;
            const filterBand = document.getElementById(`${type}-band-filter`).value;
            const filterMode = document.getElementById(`${type}-mode-filter`).value;

            let url = `/spots.json?band=${filterBand}&mode=${filterMode}`;

            try {
                const response = await fetch(url);
                const spots = await response.json();
                const tbody = document.getElementById(bodyId);
                tbody.innerHTML = '';

                if (spots.length === 0) {
                    tbody.innerHTML = `<tr><td colspan="7" style="text-align: center;">No ${type.toUpperCase()} spots received.</td></tr>`;
                } else {
                    spots.forEach(spot => {
                        if (spot.type.toLowerCase() === type) {
                            const row = tbody.insertRow();
                            const isWantedCall = isWanted(spot.dx_call);
                            const callsignClass = isWantedCall ? 'spot-call-watchlist' : 'spot-call-white-bold';
                const rowClass = isWantedCall ? 'spot-row-watchlist' : '';

                            
                            if (rowClass) row.classList.add(rowClass);
row.innerHTML = `
                                <td>${spot.time}</td>
                                <td>${spot.freq}</td>
                                <td><span class="${callsignClass}"><a href="https://qrz.com/db/${spot.dx_call}" target="_blank" title="Look up on QRZ.com">${spot.dx_call}</a></span></td>
                                <td><span class="band-tag" style="background-color: ${spot.color};">${spot.band}</span></td>
                                <td>${spot.mode}</td>
                                <td class="${(spot.score >= SPD_THRESHOLD) ? 'high-spd' : ''}">${spot.score}</td>
                                <td>${spot.distance_km.toFixed(0)}</td> `;
                            row.querySelector('td:nth-child(3)').onclick = () => {
                                if (!isWantedCall) {
                                     addToWatchlist(spot.dx_call);
                                }
                            };
                            announceSpot(spot);
                        }
                    });
                }
            } catch(e) {
                console.error(`Failed to fetch ${type} spots:`, e);
                document.getElementById(bodyId).innerHTML = `<tr><td colspan="7" style="text-align: center; color: var(--alert);">Connection Error.</td></tr>`;
            }
        }

        function displayRanking(ulId, ranks) {
            const ul = document.getElementById(ulId);
            ul.innerHTML = '';

            if (ranks.length === 0) {
                ul.innerHTML = '<li>No ranking data.</li>';
                return;
            }

            ranks.forEach(spot => {
                const li = document.createElement('li');
                li.className = 'ranking-item';
                li.innerHTML = `
                    <span class="ranking-call">${spot.dx_call} (${spot.band})</span>
                    <span class="ranking-score">${spot.score} SPD</span>
                `;
                ul.appendChild(li);
            });
        }

        function displaySurges(bands) {
            const container = document.getElementById('surge-container');
            const panel = document.getElementById('surge-panel');
            container.innerHTML = '';

            if (bands.length === 0) {
                container.textContent = 'No active surges...';
                panel.classList.remove('active-surge');
                return;
            }

            panel.classList.add('active-surge');

            bands.forEach(band => {
                const span = document.createElement('span');
                span.className = 'surge-band';
                span.textContent = `!! ${band.toUpperCase()} SURGE !!`;
                container.appendChild(span);
            });
        }

        // --- DRAG & DROP / PERSISTANCE ---
        function savePanelOrder(columnId) {
            const col = document.getElementById(columnId);
            if (!col) return;
            const panelIds = Array.from(col.children).map(panel => panel.getAttribute('data-panel-id')).filter(id => id);
            localStorage.setItem(`panel_order_${columnId}`, JSON.stringify(panelIds));
        }

        function loadPanelOrder(columnId) {
            const savedOrder = localStorage.getItem(`panel_order_${columnId}`);
            if (savedOrder) {
                const panelIds = JSON.parse(savedOrder);
                const col = document.getElementById(columnId);
                const panels = {};
                Array.from(col.children).forEach(panel => {
                    const id = panel.getAttribute('data-panel-id');
                    if (id) panels[id] = panel;
                });
                panelIds.forEach(id => {
                    if (panels[id]) col.appendChild(panels[id]);
                });
            }
        }

        function initDragAndDrop() {
            ['col1', 'col2', 'col3'].forEach(columnId => {
                const colElement = document.getElementById(columnId);
                loadPanelOrder(columnId);

                Sortable.create(colElement, {
                    group: 'panels',
                    animation: 150,
                    handle: '.dd-handle',
                    onEnd: function (evt) {
                        savePanelOrder(evt.from.id);
                        if (evt.from.id !== evt.to.id) {
                            savePanelOrder(evt.to.id);
                        }
                    }
                });
            });
        }

        // --- TH√àME ---
        function toggleTheme() {
            const themes = ['light','dark','matrix','softtech'];
            const currentTheme = document.body.getAttribute('data-theme') || 'softtech';
            const currentIndex = themes.indexOf(currentTheme);
            const nextIndex = (currentIndex + 1) % themes.length;
            const newTheme = themes[nextIndex];

            document.body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            initThemeDisplay();
            updateChartColors();
        }

        function initThemeDisplay() {
            const savedTheme = localStorage.getItem('theme') || 'softtech';
            document.body.setAttribute('data-theme', savedTheme);

            let displayName;
            switch(savedTheme) {
                case 'dark': displayName = 'Dark'; break;
                case 'matrix': displayName = 'Matrix'; break;
default: displayName = 'SoftTech';
            }
            document.getElementById('display-mode').textContent = displayName;
        }

        // --- FILTRES ---
        function populateFilterOptions() {
            const hfBandSelect = document.getElementById('hf-band-filter');
            const vhfBandSelect = document.getElementById('vhf-band-filter');

            hfBandSelect.addEventListener('change', () => updateSpots('hf'));
            document.getElementById('hf-mode-filter').addEventListener('change', () => updateSpots('hf'));

            vhfBandSelect.addEventListener('change', () => updateSpots('vhf'));
            document.getElementById('vhf-mode-filter').addEventListener('change', () => updateSpots('vhf'));

            const distanceFilterSelect = document.getElementById('voice-distance-filter');
            const savedDistanceFilter = localStorage.getItem('voiceDistanceFilter');
            if (savedDistanceFilter) {
                distanceFilterSelect.value = savedDistanceFilter;
                voiceDistanceFilter = savedDistanceFilter;
            }

            distanceFilterSelect.addEventListener('change', function() {
                voiceDistanceFilter = this.value;
                localStorage.setItem('voiceDistanceFilter', voiceDistanceFilter);
                console.log('Voice distance filter set to:', voiceDistanceFilter);
            });

            const languageFilterSelect = document.getElementById('voice-language-filter');
            const savedLanguageFilter = localStorage.getItem('voiceLanguageFilter');
            if (savedLanguageFilter) {
                languageFilterSelect.value = savedLanguageFilter;
                voiceLanguageFilter = savedLanguageFilter;
            }

            languageFilterSelect.addEventListener('change', function() {
                voiceLanguageFilter = this.value;
                localStorage.setItem('voiceLanguageFilter', voiceLanguageFilter);
                console.log('Voice language filter set to:', voiceLanguageFilter);
            });
        }

        // --- INITIALISATION S√âCURIS√âE ---
        async function initApp() {
             console.log("Starting client-side initialization...");

             const savedVoiceState = localStorage.getItem('voiceEnabled');
             isVoiceEnabled = (savedVoiceState === 'true' || savedVoiceState === null); 
             if (!isVoiceEnabled) {
                document.getElementById('synth-toggle-button').textContent = 'üîá VOICE OFF';
             }

             try {
                 const locResponse = await fetch('/user_location.json');
                 const locData = await locResponse.json();
                 userLatLng = [locData.lat, locData.lon];
                 document.getElementById('qra-display').textContent = locData.qra;
             } catch (e) {
                 console.error("CRITICAL: Failed to load user location. Using default QRA:", e);
                 userLatLng = qraToLatLng(DEFAULT_QRA);
             }

             try {
                 await loadWatchlist();
                 populateFilterOptions(); 
             } catch (e) {
                  console.error("CRITICAL: Failed to load and display Watchlist/Filters.", e);
             }

             try {
                 mapHF = initMap('map-hf');
                 mapVHF = initMap('map-vhf');
                 userMarkerHF = addUserMarker(mapHF, userLatLng[0], userLatLng[1]);
                 userMarkerVHF = addUserMarker(mapVHF, userLatLng[0], userLatLng[1]);
                 mapHF.invalidateSize();
                 mapVHF.invalidateSize();
             } catch (e) {
                 console.error("CRITICAL: Failed to initialize Maps/Markers. Check Leaflet scripts.", e);
             }

             initThemeDisplay();

             try {
                  initCharts();
             } catch (e) {
                 console.error("CRITICAL: Failed to initialize Charts. Check Chart.js script.", e);
             }

             try {
                 initDragAndDrop();
             } catch (e) {
                 console.error("Failed to initialize Drag and Drop. Check Sortable.js script.", e);
             }

             setInterval(updateTimeDisplay, 1000);

             try {
                 await updateData();
             } catch (e) {
                 console.error("CRITICAL: Initial updateData() failed. Spots/Ticker may not show initially.", e);
             }

             setInterval(updateData, 30000);

             // Solar indices: initial load + hourly refresh
             try { await fetchSolar(); } catch(e) {}
             setInterval(fetchSolar, 3600000);

             document.getElementById('qra-form').addEventListener('submit', async function(event) {
                 event.preventDefault();
                 const formData = new FormData(event.target);
                 try {
                     const response = await fetch('/update_qra', {
                         method: 'POST',
                         body: formData
                     });
                     if (response.ok) {
                        const locResponse = await fetch('/user_location.json');
                        const locData = await locResponse.json();
                        userLatLng = [locData.lat, locData.lon];
                        document.getElementById('qra-display').textContent = locData.qra;
                        userMarkerHF.setLatLng(userLatLng);
                        userMarkerVHF.setLatLng(userLatLng);
                        mapHF.setView(userLatLng, mapHF.getZoom());
                        mapVHF.setView(userLatLng, mapVHF.getZoom());
                        await updateData();
                        alert(`QTH updated to ${locData.qra}`);
                     } else {
                        alert('QTH update failed. Please check the locator format.');
                     }
                 } catch (e) {
                     console.error("Error submitting QRA form:", e);
                     alert('Network error while updating QRA.');
                 }
             });

             document.getElementById('add-wl-form').addEventListener('submit', async function(event) {
                 event.preventDefault();
                 const callsignInput = document.getElementById('wl_callsign');
                 const callsign = callsignInput.value.trim().toUpperCase();
                 if (callsign) {
                     await addToWatchlist(callsign);
                     callsignInput.value = '';
                 }
             });
         }

        document.addEventListener('DOMContentLoaded', initApp);
    
// --- Spot manuel vers DX Cluster ---
(function(){
  const elCall = document.getElementById('spot-call');
  const elFreq = document.getElementById('spot-freq');
  const elCom  = document.getElementById('spot-comment');
  const elBtn  = document.getElementById('spot-send');
  const elSt   = document.getElementById('spot-status');
  if(!elBtn) return;

  function setStatus(msg, ok=true){
    elSt.textContent = msg;
    elSt.style.opacity = ok ? '0.85' : '1';
    elSt.style.color = ok ? 'var(--text-main)' : 'var(--alert)';
  }

  async function doSpot(){
    const call = (elCall.value || '').trim().toUpperCase();
    const freq = (elFreq.value || '').trim();
    const comment = (elCom.value || '').trim();
    if(!call || !freq){
      setStatus('CALL + fr√©quence requis.', false);
      return;
    }
    elBtn.disabled = true;
    setStatus('Envoi au cluster‚Ä¶');
    try{
      const r = await fetch('/spot', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({call, freq, comment})
      });
      const j = await r.json().catch(()=>({ok:false, error:'R√©ponse invalide'}));
      if(!r.ok || !j.ok){
        setStatus(j.error || ('Erreur HTTP ' + r.status), false);
        return;
      }
      setStatus('Spot envoy√© ‚úî');
      try{
        if(typeof speakText === 'function' && (window.ttsEnabled || document.getElementById('tts-toggle')?.checked)){
          speakText(`Spot envoy√© ${call}`);
        }
      }catch(e){}
    }catch(e){
      setStatus('Erreur r√©seau: '+e.message, false);
    }finally{
      elBtn.disabled = false;
    }
  }

  elBtn.addEventListener('click', doSpot);
  [elCall, elFreq, elCom].forEach(inp=>{
    inp.addEventListener('keydown', (ev)=>{
      if(ev.key === 'Enter'){ ev.preventDefault(); doSpot(); }
    });
  });
})();
// =========================
// WATCHLIST TRACKING PANEL
// =========================
async function loadWatchlistTracking(){
  const body = document.getElementById('wl-track-body');
  const status = document.getElementById('wl-track-status');
  const filter = document.getElementById('wl-track-filter').value.trim();
  const limit  = document.getElementById('wl-track-limit').value;

  body.innerHTML = '';
  status.textContent = 'Chargement‚Ä¶';
// ‚õî Champ filtre vide ‚Üí pav√© neutre
if (!filter) {
  body.innerHTML = `
    <div style="opacity:.7; font-size:0.85em;">
      Tapez un filtre pour suivre un indicatif (ex: 9, VK, /P)
    </div>
  `;
  status.textContent = 'Aucun filtre actif';
  return;
}
  try{
    const url = `/api/watchlist/tracking.json?limit=${limit}&q=${encodeURIComponent(filter)}`;
    const r = await fetch(url, {cache:'no-store'});
    if(!r.ok) throw new Error(r.status);

    const data = await r.json();
    const calls = data.calls || {};

    let rendered = 0;
    for(const call in calls){
      const spots = calls[call];
      const rows = spots.map(s => `
        <div style="display:flex; justify-content:space-between; font-size:0.8em;">
          <span>${s.utc}</span>
          <span>${s.band} ${s.mode}</span>
          <span>${s.freq_khz || ''}</span>
        </div>
      `).join('');

      body.innerHTML += `
        <div style="border:1px solid #333; border-radius:8px; padding:6px;">
          <div style="font-weight:bold; color:var(--accent); margin-bottom:4px;">
            ${call}
          </div>
          ${rows || '<div style="opacity:.6;">Aucun spot r√©cent</div>'}
        </div>
      `;
      rendered++;
    }

    status.textContent =
      `${rendered} call(s) suivis ¬∑ maj ${data.generated_utc.split('T')[1].slice(0,5)} UTC`;

  }catch(e){
    status.textContent = 'Erreur tracking';
    body.innerHTML = '<div style="color:var(--alert);">API indisponible</div>';
  }
}

// hooks
document.getElementById('wl-track-refresh').onclick = loadWatchlistTracking;
document.getElementById('wl-track-filter').oninput = () => {
  clearTimeout(window._wlTrackDebounce);
  window._wlTrackDebounce = setTimeout(loadWatchlistTracking, 400);
};
document.getElementById('wl-track-limit').onchange = loadWatchlistTracking;

// refresh auto toutes les 30s
setInterval(loadWatchlistTracking, 30000);

</script>
</body>
</html>
