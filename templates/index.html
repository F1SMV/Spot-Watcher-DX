<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURAL DX v3.1 - REDBULL OPS</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #050505;
            --panel-bg: #0e0e0e;
            --text-main: #a0a0a0;
            --accent: #00f3ff;
            --alert: #ff003c;
            --border: 1px solid #333;
            --wl-bg: #ffeb3b; /* Jaune vif */
            --wl-text: #000000;
            --open-color: #d35400; /* Couleur pour l'alerte d'ouverture (12m/10m/6m) */
        }
        
        /* THEMES */
        body.matrix { --accent: #0f0; --bg-color: #000; --text-main: #0f0; }
        body.amber { --accent: #ffae00; --bg-color: #1a1000; --text-main: #d4a017; }
        body.neon { --accent: #ff00ff; --bg-color: #0a000a; --text-main: #ffccff; }
        
        body { background-color: var(--bg-color); color: var(--text-main); font-family: 'Share Tech Mono', monospace; margin: 0; overflow-x: hidden; }
        
        /* HEADER */
        header { 
            display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; 
            background: #000; border-bottom: 1px solid #222; 
        }
        h1 { font-family: 'Orbitron', sans-serif; color: var(--accent); margin: 0; font-size: 1.4rem; text-shadow: 0 0 10px var(--accent); }
        .time-display { font-size: 0.8rem; text-align: right; } /* STYLE HEURE */
        
        /* TICKER */
        .ticker-wrap {
            width: 100%; overflow: hidden; background-color: #111; border-bottom: 1px solid var(--accent);
            height: 30px; line-height: 30px; position: relative;
        }
        .ticker-move { display: inline-block; white-space: nowrap; animation: ticker 45s linear infinite; padding-left: 100%; }
        .ticker-item { display: inline-block; padding: 0 2rem; color: var(--accent); font-weight: bold; font-size: 1.1em; }
        @keyframes ticker { 0% { transform: translate3d(0, 0, 0); } 100% { transform: translate3d(-100%, 0, 0); } }

        /* COMMAND DECK */
        .command-deck {
            display: flex; align-items: center; gap: 15px; background: #080808; padding: 10px 20px; border-bottom: 1px solid #333; flex-wrap: wrap;
        }
        .control-group { display: flex; align-items: center; gap: 8px; }
        select, input, button {
            background: #000; border: 1px solid var(--accent); color: var(--accent); padding: 5px 10px; font-family: 'Share Tech Mono'; cursor: pointer; outline: none;
        }
        button:hover { background: var(--accent); color: #000; }
        
        /* WATCHLIST TAGS */
        #watchlist-container { display: flex; gap: 5px; align-items: center; flex-wrap: wrap; }
        .watchlist-item { background: var(--wl-bg); color: var(--wl-text); padding: 2px 6px; border-radius: 3px; font-size: 0.8rem; cursor: pointer; border: 1px solid #444; font-weight: bold; }
        .watchlist-item:hover { background: var(--alert); color: #fff; }

        /* SECTORS LAYOUT */
        .sector-container { margin-bottom: 40px; border-bottom: 2px dashed #333; padding-bottom: 20px; }
        
        .sector-title {
            background: #111; color: #fff; padding: 8px 20px; font-family: 'Orbitron'; 
            border-top: 1px solid var(--accent); border-bottom: 1px solid var(--accent);
            margin-top: 0; display: flex; align-items: center; gap: 15px; font-size: 1.2rem;
        }
        .hf-style .sector-title { border-color: #e67e22; color: #e67e22; }
        .vhf-style .sector-title { border-color: #e84393; color: #e84393; }

        /* GRID SYSTEM */
        .main-grid {
            display: grid; grid-template-columns: 65% 35%; gap: 10px; padding: 10px;
            height: 45vh; min-height: 400px;
        }
        .secondary-grid {
            display: grid; grid-template-columns: 50% 50%; gap: 10px; padding: 0 10px 10px 10px;
            height: 35vh; min-height: 300px;
        }
        .tertiary-grid { /* GRILLE 24H */
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px; padding: 0 10px 10px 10px;
            height: 30vh; min-height: 250px;
        }

        .panel { background: var(--panel-bg); border: var(--border); padding: 0; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        .panel h3 { margin: 0; padding: 8px; background: #151515; font-size: 0.9rem; border-bottom: 1px solid #333; color: #ddd; }
        
        .map-wrapper { height: 100%; width: 100%; }
        .chart-wrapper { position: relative; flex: 1; padding: 10px; min-height: 0; }

        .scroll-list { flex: 1; overflow-y: auto; font-size: 0.85rem; scrollbar-width: thin; scrollbar-color: var(--accent) #000; }
        
        /* SPOT ROWS */
        .spot-row { 
            display: grid; 
            /* AJOUT DE 50px POUR LE MODE (3√®me colonne) */
            grid-template-columns: 70px 60px 50px 100px auto 60px; 
            gap: 10px; 
            padding: 4px 8px; 
            border-bottom: 1px solid #222; 
            align-items: center;
        }
        /* Style sp√©cifique pour la grille des WANTED (5 colonnes) */
        .wanted-row-grid {
             grid-template-columns: 70px 60px 100px auto 60px !important;
        }
        
        .spot-row:hover { background: #1a1a1a; color: #fff; }
        
        /* STYLE WATCHLIST MATCH (JAUNE) */
        .spot-row.watched {
            background-color: var(--wl-bg) !important;
            color: var(--wl-text) !important;
            font-weight: bold;
            border: 1px solid #fff;
        }
        .spot-row.watched .spot-freq, 
        .spot-row.watched .spot-call, 
        .spot-row.watched .spot-country { color: var(--wl-text) !important; }

        .spot-freq { color: var(--accent); text-align: right; font-family: monospace; }
        .spot-band { text-align: center; border-radius: 3px; color: #000; font-weight: bold; font-size: 0.8rem; padding: 1px 0; }
        
        /* NOUVEAU STYLE PASTILLE MODE */
        .spot-mode { 
            text-align: center; 
            font-size: 0.75rem; 
            color: #fff; 
            background: #333; 
            border: 1px solid #555; 
            border-radius: 3px; 
            padding: 1px 3px; 
            white-space: nowrap; 
        }
        
        /* STYLE POUR L'INDICATIF (lien) */
        .spot-call a { font-weight: bold; color: #fff; letter-spacing: 1px; text-decoration: none; }
        .spot-call a:hover { color: var(--accent); text-decoration: underline; }
        
        .spot-country { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: #888; }
        
        /* STYLE DISTANCE */
        .spot-distance {
            text-align: right;
            color: var(--accent); /* Couleur d'accentuation */
            font-weight: bold;
        }

        /* ALERTS */
        .surge-banner { display: none; background: var(--alert); color: #fff; font-size: 0.8rem; padding: 2px 8px; border-radius: 2px; animation: blink 1s infinite; text-transform: uppercase; letter-spacing: 1px; font-weight: bold; }
        @keyframes blink { 50% { opacity: 0.5; } }
        
        /* NOUVEAU STYLE ALERTE OUVERTURE */
        .open-alert { 
            background: var(--panel-bg); color: var(--open-color); border: 2px dashed var(--open-color); 
            padding: 10px; margin: 10px; text-align: center; font-size: 1.1em; font-weight: bold;
        }
        
        /* QRA FEEDBACK */
        .qra-valid { color: #0f0; } /* Vert */
        .qra-invalid { color: var(--alert); } /* Rouge */

    </style>
</head>
<body>

<header>
    <h1>NEURAL DX <span style="font-size:0.6em; opacity:0.7; color:#fff">v3.1</span></h1>
    <div class="time-display">
        <span id="utc-time"></span><br>
        <span id="local-time"></span>
    </div>
    <div class="control-group">
        <button onclick="toggleTheme()">THEME</button>
        <button onclick="toggleVoice()">VOICE: <span id="voice-status">OFF</span></button>
    </div>
</header>

<div class="ticker-wrap">
    <div class="ticker-move" id="ticker-content">
        <div class="ticker-item">INITIALISATION DU SYSTEME...</div>
    </div>
</div>

<div class="command-deck">
    <div class="control-group">
        <span>FILTERS:</span>
        <select id="filter-band" onchange="updateData()">
            <option value="All">All Bands</option>
            {% for b in hf_bands + vhf_bands %}
            <option value="{{ b }}">{{ b }}</option>
            {% endfor %}
        </select>
        <select id="filter-mode" onchange="updateData()">
            <option value="All">All Modes</option>
            <option value="CW">CW</option>
            <option value="SSB">SSB</option>
            <option value="FT8">FT8</option>
            <option value="FT4">FT4</option>
            <option value="FM">FM</option>
            <option value="DIGI">DIGI</option>
            <option value="MSK144">MSK144</option>
            <option value="SSTV">SSTV</option>
        </select>
    </div>
    
    <div class="control-group" style="border-left: 1px solid #333; padding-left: 20px;">
        <span>QRA LOCATOR:</span>
        <input type="text" id="qra-input" placeholder="JN33" style="width: 70px; text-transform: uppercase;" maxlength="6" onkeyup="clearQraFeedback()">
        <button onclick="goToQra()">GO</button>
        <span id="qra-feedback" style="margin-left: 10px; font-size: 0.8rem; font-weight: bold;"></span> 
    </div>

    <div class="control-group" style="margin-left: auto; border-left: 1px solid #333; padding-left: 20px;">
        <span>WATCHLIST:</span>
        <input type="text" id="wl-input" placeholder="Call..." style="width: 70px; text-transform: uppercase;">
        <button onclick="addToWatchlist()">ADD</button>
        <div id="watchlist-container"></div>
    </div>
</div>

<div class="sector-container hf-style">
    <div class="sector-title">
        üì° HF GLOBAL & MAGIC BAND (160m - 6m) 
        <span id="hf-surge-alert" class="surge-banner">‚ö†Ô∏è SURGE</span>
    </div>
    
    <div class="main-grid">
        <div class="panel">
            <div id="map-hf" class="map-wrapper"></div>
        </div>
        <div class="panel">
            <h3>üèÜ TOP DX WANTED</h3>
            <div style="font-weight: bold; padding: 4px 8px; background: #151515; display: grid; grid-template-columns: 70px 60px 100px auto 60px; gap: 10px;">
                <span>Score</span><span>Band</span><span>Call</span><span>Country</span><span style="text-align:right;">km</span>
            </div>
            <div id="wanted-hf" class="scroll-list"></div>
        </div>
    </div>

    <div class="secondary-grid">
        <div class="panel">
            <h3>üåä LIVE STREAM</h3>
            <div style="font-weight: bold; padding: 4px 8px; background: #151515; display: grid; grid-template-columns: 70px 60px 50px 100px auto 60px; gap: 10px;">
                <span>Freq</span><span>Band</span><span>Mode</span><span>Call</span><span>Country</span><span style="text-align:right;">km</span>
            </div>
            <div id="list-hf" class="scroll-list"></div>
        </div>
        <div class="panel">
            <h3>üìä ACTIVITY</h3>
            <div class="chart-wrapper">
                <canvas id="chart-hf"></canvas>
            </div>
        </div>
    </div>
</div>

<div class="sector-container hf-style">
    <div class="sector-title">
        üìä PROPAGATION HISTORY (12m / 10m / 6m) 24H
    </div>
    
    <div class="tertiary-grid">
        <div class="panel">
            <div id="open-alert-panel" class="open-alert">
                SCANNING FOR OPENINGS...
            </div>
        </div>
        <div class="panel">
            <h3>HOURLY SPOTS (12m/10m/6m)</h3>
            <div class="chart-wrapper">
                <canvas id="chart-history"></canvas>
            </div>
        </div>
    </div>
</div>
<div class="sector-container vhf-style">
    <div class="sector-title">
        üõ∞Ô∏è VHF / UHF / SPACE 
        <span id="vhf-surge-alert" class="surge-banner">‚ö†Ô∏è SURGE</span>
    </div>
    
    <div class="main-grid">
        <div class="panel">
            <div id="map-vhf" class="map-wrapper"></div>
        </div>
        <div class="panel">
            <h3>üöÄ TOP VHF WANTED</h3>
            <div style="font-weight: bold; padding: 4px 8px; background: #151515; display: grid; grid-template-columns: 70px 60px 100px auto 60px; gap: 10px;">
                <span>Score</span><span>Band</span><span>Call</span><span>Country</span><span style="text-align:right;">km</span>
            </div>
            <div id="wanted-vhf" class="scroll-list"></div>
        </div>
    </div>

    <div class="secondary-grid">
        <div class="panel">
            <h3>üåä LIVE STREAM</h3>
            <div style="font-weight: bold; padding: 4px 8px; background: #151515; display: grid; grid-template-columns: 70px 60px 50px 100px auto 60px; gap: 10px;">
                <span>Freq</span><span>Band</span><span>Mode</span><span>Call</span><span>Country</span><span style="text-align:right;">km</span>
            </div>
            <div id="list-vhf" class="scroll-list"></div>
        </div>
        <div class="panel">
            <h3>üìä ACTIVITY</h3>
            <div class="chart-wrapper">
                <canvas id="chart-vhf"></canvas>
            </div>
        </div>
    </div>
</div>


<script>
    const BAND_COLORS = {{ band_colors|tojson }};
    const HF_BANDS = {{ hf_bands|tojson }};
    const VHF_BANDS = {{ vhf_bands|tojson }};
    const HISTORY_BANDS = ['12m', '10m', '6m']; 

    // COORDONN√âES DE D√âPART DE L'UTILISATEUR (par d√©faut JN33)
    const DEFAULT_QRA = 'JN33';
    let userLatLng = null;
    
    // Pour g√©rer la temporisation du feedback QRA (40 secondes)
    let qraFeedbackTimeout = null; 

    // --- FONCTIONS G√âOM√âTRIQUES ---

    // 1. Conversion QRA Locator -> Lat/Lon
    function qraToLatLng(qra) {
        qra = qra.toUpperCase();
        if (qra.length < 4) return null;
        
        let lon = -180, lat = -90;
        
        // 1. Field (Ex: JN) -> 18¬∞ par caract√®re (A=0)
        lon += (qra.charCodeAt(0) - 65) * 20;
        lat += (qra.charCodeAt(1) - 65) * 10;
        
        if (qra.length >= 4) {
            // 2. Square (Ex: 33) -> 2¬∞ par chiffre
            lon += parseInt(qra[2]) * 2;
            lat += parseInt(qra[3]) * 1;
        }

        if (qra.length >= 6) {
            // 3. Subsquare (Ex: XX) -> 5 minutes de lat/lon (1/24eme de degr√©)
            lon += (qra.charCodeAt(4) - 65) * (2/24);
            lat += (qra.charCodeAt(5) - 65) * (1/24);
            // On centre au milieu de la sous-case
            lon += (1/24);
            lat += (1/48);
        } else {
             // On centre au milieu de la case de 2x1 degr√©s
            lon += 1;
            lat += 0.5;
        }

        return [lat, lon];
    }
    
    // 2. Calcul de la distance (Formule de Haversine)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        if (lat1 === undefined || lon1 === undefined || lat2 === undefined || lon2 === undefined) return null;
        const R = 6371; // Rayon de la Terre en kilom√®tres
        const toRad = (x) => x * Math.PI / 180;
        
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        
        return R * c; // Distance en km
    }


    // --- LOGIQUE QRA LOCATOR ET CARTE ---

    function isValidQra(qra) {
        // Validation basique: 4 ou 6 caract√®res
        if (qra.length === 4) {
            return /^[A-R][A-R]\d\d$/.test(qra);
        }
        if (qra.length === 6) {
            return /^[A-R][A-R]\d\d[A-X][A-X]$/.test(qra);
        }
        return false;
    }
    
    function clearQraFeedback() {
        const feedbackSpan = document.getElementById('qra-feedback');
        feedbackSpan.innerText = "";
        feedbackSpan.className = "";
        qraFeedbackTimeout = null; // R√©initialise l'ID du timeout
    }

    function goToQra() {
        const qraInput = document.getElementById('qra-input');
        const feedbackSpan = document.getElementById('qra-feedback');
        const qra = qraInput.value.trim().toUpperCase();

        // Annule le timeout pr√©c√©dent si l'utilisateur appuie rapidement sur GO
        if (qraFeedbackTimeout) {
            clearTimeout(qraFeedbackTimeout);
            qraFeedbackTimeout = null;
        }

        feedbackSpan.innerText = "";
        feedbackSpan.className = "";

        if (!isValidQra(qra)) {
            feedbackSpan.innerText = "Invalid / Invalide";
            feedbackSpan.classList.add('qra-invalid');
            
            // D√©finit le nouveau timeout de 40 secondes
            qraFeedbackTimeout = setTimeout(clearQraFeedback, 40000);
            return;
        }
        
        const latLon = qraToLatLng(qra);

        if (latLon) {
            // Success Feedback
            feedbackSpan.innerText = "Valid / Valide";
            feedbackSpan.classList.add('qra-valid');
            
            // D√©finit le nouveau timeout de 40 secondes
            qraFeedbackTimeout = setTimeout(clearQraFeedback, 40000);

            // Stocke la position de l'utilisateur pour le calcul de distance
            userLatLng = latLon; 
            
            // Determine the map and zoom level
            let targetMap = mapHF;
            let zoomLevel = qra.length === 4 ? 6 : 9; 
            
            // Si le QRA est dans la zone Europe/Proche
            if (latLon[0] >= 30 && latLon[0] <= 60 && latLon[1] >= -10 && latLon[1] <= 30) {
                 targetMap = mapVHF;
                 zoomLevel = qra.length === 4 ? 7 : 10;
            }

            targetMap.setView(latLon, zoomLevel, { animate: true });
            
            // Si le QRA est valid√©, on relance updateData pour recalculer les distances
            updateData(); 
            
        } else {
            feedbackSpan.innerText = "Error / Erreur";
            feedbackSpan.classList.add('qra-invalid');
            qraFeedbackTimeout = setTimeout(clearQraFeedback, 40000);
        }
    }


    const mapHF = L.map('map-hf', { attributionControl: false }).setView([25, 0], 2);
    const mapVHF = L.map('map-vhf', { attributionControl: false }).setView([48, 10], 3);

    const tileUrl = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
    L.tileLayer(tileUrl, { maxZoom: 19 }).addTo(mapHF);
    L.tileLayer(tileUrl, { maxZoom: 19 }).addTo(mapVHF);

    let markersHF = [], markersVHF = [];
    let voiceEnabled = false;
    let watchlist = [];
    let lastTickerText = "";
    let historyChartData = {};

    // Charts (Configuration inchang√©e)
    const commonOptions = {
        responsive: true, maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: { 
            y: { beginAtZero: true, grid: { color: '#222' }, ticks: { color: '#666', font: {size: 9} } }, 
            x: { grid: { color: '#222' }, ticks: { color: '#888', font: {size: 9} } } 
        },
        animation: false
    };

    function createChart(id, labels) {
        const ctx = document.getElementById(id).getContext('2d');
        const bgColors = labels.map(b => BAND_COLORS[b] || '#555');
        return new Chart(ctx, {
            type: 'bar',
            data: { labels: labels, datasets: [{ data: [], backgroundColor: bgColors, borderRadius: 2 }] },
            options: commonOptions
        });
    }
    
    function createHistoryChart(id) {
         const ctx = document.getElementById(id).getContext('2d');
         return new Chart(ctx, {
            type: 'bar',
            data: { 
                labels: [], 
                datasets: HISTORY_BANDS.map(band => ({
                    label: band,
                    data: [],
                    backgroundColor: BAND_COLORS[band],
                    borderRadius: 2
                }))
            },
            options: {
                ...commonOptions,
                scales: {
                    ...commonOptions.scales,
                    x: {
                        grid: { color: '#222' }, 
                        ticks: { 
                            color: '#888', 
                            font: {size: 8},
                            maxRotation: 45,
                            minRotation: 45
                        }
                    }
                },
                plugins: {
                    legend: { display: true, position: 'top', labels: { color: '#ddd' } },
                },
                animation: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                indexAxis: 'x'
            }
        });
    }

    const chartHF = createChart('chart-hf', HF_BANDS);
    const chartVHF = createChart('chart-vhf', VHF_BANDS);
    const chartHistory = createHistoryChart('chart-history'); 

    // UI Utils (inchang√©es)
    const themes = ['', 'matrix', 'amber', 'neon'];
    let currentTheme = 0;
    function toggleTheme() {
        currentTheme = (currentTheme + 1) % themes.length;
        document.body.className = themes[currentTheme];
    }

    function toggleVoice() {
        voiceEnabled = !voiceEnabled;
        document.getElementById('voice-status').innerText = voiceEnabled ? "ON" : "OFF";
        if(voiceEnabled) speak("Voice systems online.");
    }

    function speak(text) {
        if (!voiceEnabled) return;
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'en-US'; u.rate = 1.2; u.pitch = 0.9;
        window.speechSynthesis.speak(u);
    }
    
    function updateTimeDisplay() {
        const utcDate = new Date();
        const localDate = new Date();
        
        const formatOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit' };

        // UTC Time
        const utcTime = utcDate.toLocaleTimeString('fr-FR', {...formatOptions, timeZone: 'UTC' });
        document.getElementById('utc-time').innerText = `UTC: ${utcTime}`;

        // Local Time
        const localTime = localDate.toLocaleTimeString('fr-FR', formatOptions);
        document.getElementById('local-time').innerText = `LOCAL: ${localTime}`;
    }

    // Watchlist (inchang√©es)
    async function loadWatchlist() {
        const r = await fetch('/watchlist.json');
        watchlist = await r.json();
        const container = document.getElementById('watchlist-container');
        container.innerHTML = watchlist.map(c => 
            `<span class="watchlist-item" onclick="removeFromWatchlist('${c}')">${c} &times;</span>`
        ).join('');
    }

    async function addToWatchlist() {
        const input = document.getElementById('wl-input');
        const call = input.value.trim().toUpperCase();
        if(!call) return;
        await fetch('/watchlist.json', { method: 'POST', body: JSON.stringify({call: call}) });
        input.value = ''; loadWatchlist();
    }

    async function removeFromWatchlist(call) {
        await fetch('/watchlist.json', { method: 'DELETE', body: JSON.stringify({call: call}) });
        loadWatchlist();
    }

    // Render Row - LIVE STREAM (AJOUT DU MODE)
    function createSpotRow(s) {
        const isWatched = watchlist.includes(s.dx_call);
        const rowClass = isWatched ? 'spot-row watched' : 'spot-row';
        
        // Calcul de la distance
        let distance = '';
        if (userLatLng && s.lat !== undefined && s.lon !== undefined) {
            const dist = calculateDistance(userLatLng[0], userLatLng[1], s.lat, s.lon);
            if (dist !== null) {
                // Utilise toLocaleString pour les s√©parateurs de milliers (ex: 12 456km)
                distance = `${Math.round(dist).toLocaleString('fr-FR')}km`;
            }
        }
        
        return `
            <div class="${rowClass}">
                <span class="spot-freq">${s.freq}</span>
                <span class="spot-band" style="background:${s.color}">${s.band}</span>
                <span class="spot-mode">${s.mode}</span> <span class="spot-call"><a href="https://qrz.com/db/${s.dx_call}" target="_blank">${s.dx_call}</a></span>
                <span class="spot-country">${s.country}</span>
                <span class="spot-distance">${distance}</span>
            </div>`;
    }

    // Render Row - TOP DX WANTED (Pas de Mode, on r√©utilise la grille 5 colonnes)
    function createWantedRow(s) {
        // Calcul de la distance
        let distance = '';
        if (userLatLng && s.lat !== undefined && s.lon !== undefined) {
            const dist = calculateDistance(userLatLng[0], userLatLng[1], s.lat, s.lon);
            if (dist !== null) {
                distance = `${Math.round(dist).toLocaleString('fr-FR')}km`;
            }
        }

        return `
            <div class="spot-row wanted-row-grid" style="border-left: 3px solid ${s.color}">
                <span class="spot-freq" style="color:#666">${s.score}pts</span>
                <span class="spot-band" style="background:${s.color}">${s.band}</span>
                <span class="spot-call"><a href="https://qrz.com/db/${s.dx_call}" target="_blank">${s.dx_call}</a></span>
                <span class="spot-country">${s.country}</span>
                <span class="spot-distance">${distance}</span>
            </div>`;
    }

    // Main Loop
    async function updateData() {
        updateTimeDisplay(); 
        
        const fBand = document.getElementById('filter-band').value;
        const fMode = document.getElementById('filter-mode').value;
        
        try {
            const [rSpots, rWanted, rSurge, rRss, rHistory] = await Promise.all([
                fetch(`/spots.json?band=${fBand}&mode=${fMode}`),
                fetch('/wanted.json'),
                fetch('/surge.json'),
                fetch('/rss.json'),
                fetch('/history.json') 
            ]);

            const spots = await rSpots.json();
            const wanted = await rWanted.json();
            const surge = await rSurge.json();
            const rss = await rRss.json();
            historyChartData = await rHistory.json(); 

            // RSS Update 
            if (rss.ticker !== lastTickerText) {
                document.getElementById('ticker-content').innerHTML = `<div class="ticker-item">${rss.ticker}</div>`;
                lastTickerText = rss.ticker;
            }

            // Clear 
            document.getElementById('list-hf').innerHTML = '';
            document.getElementById('list-vhf').innerHTML = '';
            markersHF.forEach(m => mapHF.removeLayer(m)); markersHF = [];
            markersVHF.forEach(m => mapVHF.removeLayer(m)); markersVHF = [];
            
            const statsHF = {}, statsVHF = {};

            // Process Spots 
            spots.forEach(s => {
                if(fBand !== 'All' && s.band !== fBand) return;
                if(fMode !== 'All' && s.mode !== fMode) return;

                const isVHF = s.type === 'VHF';
                const targetList = isVHF ? 'list-vhf' : 'list-hf';

                document.getElementById(targetList).insertAdjacentHTML('beforeend', createSpotRow(s));
                
                // Markers logic (inchang√©e)
                const targetMap = isVHF ? mapVHF : mapHF;
                const m = L.circleMarker([s.lat, s.lon], {
                    radius: 4, color: s.color, fillColor: s.color, fillOpacity: 0.9, weight: 1
                }).bindPopup(`<b>${s.dx_call}</b><br>${s.freq} (${s.mode})<br>${s.country}`);
                
                m.addTo(targetMap);
                if(isVHF) markersVHF.push(m); else markersHF.push(m);

                if(isVHF) statsVHF[s.band] = (statsVHF[s.band] || 0) + 1;
                else statsHF[s.band] = (statsHF[s.band] || 0) + 1;

                if (watchlist.includes(s.dx_call) && (Date.now()/1000 - s.timestamp) < 10) {
                    speak(`Alert. Watchlist target ${s.dx_call} spotted on ${s.band}`);
                }
            });

            // Charts 
            chartHF.data.datasets[0].data = HF_BANDS.map(b => statsHF[b] || 0);
            chartHF.update();
            chartVHF.data.datasets[0].data = VHF_BANDS.map(b => statsVHF[b] || 0);
            chartVHF.update();
            
            // Mise √† jour du Chart Historique 24H
            chartHistory.data.labels = historyChartData.labels;
            
            let totalSpotsLastHour = 0;
            chartHistory.data.datasets.forEach(dataset => {
                dataset.data = historyChartData.data[dataset.label] || [];
                totalSpotsLastHour += dataset.data[dataset.data.length - 1] || 0;
            });
            chartHistory.update();

            // Wanted 
            document.getElementById('wanted-hf').innerHTML = wanted.hf.map(createWantedRow).join('');
            document.getElementById('wanted-vhf').innerHTML = wanted.vhf.map(createWantedRow).join('');

            // Updated Surge Logic 
            const hfSurges = surge.surges.filter(b => HF_BANDS.includes(b));
            const vhfSurges = surge.surges.filter(b => VHF_BANDS.includes(b));
            
            const hfAlert = document.getElementById('hf-surge-alert');
            if(hfSurges.length > 0) {
                hfAlert.innerText = "‚ö†Ô∏è SURGE: " + hfSurges.join(', ');
                hfAlert.style.display = 'inline-block';
            } else { hfAlert.style.display = 'none'; }

            const vhfAlert = document.getElementById('vhf-surge-alert');
            if(vhfSurges.length > 0) {
                vhfAlert.innerText = "‚ö†Ô∏è SURGE: " + vhfSurges.join(', ');
                vhfAlert.style.display = 'inline-block';
            } else { vhfAlert.style.display = 'none'; }

            if((hfSurges.length || vhfSurges.length) && voiceEnabled && Math.random() > 0.9) speak("Propagation alert.");
            
            // Alerte d'ouverture
            const openAlertPanel = document.getElementById('open-alert-panel');
            let openingBands = HISTORY_BANDS.filter(band => {
                const dataList = historyChartData.data[band] || [];
                const lastHourSpots = dataList[dataList.length - 1] || 0;
                // On consid√®re qu'il y a ouverture si > 5 spots dans la derni√®re heure
                return lastHourSpots > 5; 
            });

            if (openingBands.length > 0) {
                openAlertPanel.innerHTML = `üö® **OUVERTURE DETECTEE** üö®<br>**${openingBands.join(' / ')}**`;
                openAlertPanel.style.backgroundColor = 'var(--open-color)';
                openAlertPanel.style.color = 'var(--wl-text)';
                openAlertPanel.style.animation = 'blink 1s infinite';
            } else {
                openAlertPanel.innerHTML = `SCANNING FOR OPENINGS...`;
                openAlertPanel.style.backgroundColor = 'var(--panel-bg)';
                openAlertPanel.style.color = 'var(--open-color)';
                openAlertPanel.style.animation = 'none';
            }


        } catch(e) { console.error(e); }
    }
    
    // --- INITIALISATION ---
    // Initialise la position de l'utilisateur avec un QRA par d√©faut
    userLatLng = qraToLatLng(DEFAULT_QRA);

    loadWatchlist();
    setInterval(updateTimeDisplay, 1000); 
    setInterval(updateData, 3000);
    updateData();

</script>
</body>
</html>